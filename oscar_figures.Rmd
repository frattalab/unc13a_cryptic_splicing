---
title: "oscar_figures"
author: "Oscar Wilkins"
date: "14/03/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(DESeq2)
library(here)
library(ggrepel)
```

## Ribosome profiling quality control

TODO: convert all libraries to p_load.

Perform quality control to check that reads are periodic.

```{r message=FALSE, warning=FALSE}
read_length_filter <- 29  # length of reads of interest
gencode_v29_info <- read_tsv(paste0(here(), "/data/longest_proteincoding_transcript_hs_details.txt"))
ribo_df <- read_tsv(paste0(here(), "/data/riboseq/sh_tdpb.Aligned.toTranscriptome.out.bam.bed.gz"), 
                    col_names = c("transcript_id", "start0", "end", "strand")) %>%
    inner_join(gencode_v29_info, by = "transcript_id") %>%
    dplyr::filter(end-start0 == read_length_filter, strand == "+") %>%
    mutate(distance_from_start = start0-cds_start) %>%
    group_by(distance_from_start) %>%
    mutate(n_this_dist = n()) %>%
    dplyr::select(distance_from_start, n_this_dist) %>%
    unique()
    
```

```{r, warning=FALSE}
ggplot(ribo_df, aes(x=distance_from_start, y=n_this_dist)) +
    geom_bar(stat="identity") +
    xlim(-50, 50) +
    ylab("Counts") + 
    xlab("Distance of 5' end from annotated start codon") +
    ggtitle(paste0("Periodicity of ", read_length_filter, "nt reads from TDP-43 KD replicate B"))
```

## Ribosome profiling volcano plot

Use DESeq to detect differential ribosome footprints and create volcano plots

```{r message = FALSE, warning=FALSE}
counts_df <- read_csv(paste0(here(), "/data/riboseq/cds_feature_counts.csv"))
counts <- as.matrix(counts_df %>% column_to_rownames("gene_id"))
ipsc_splicing <- read_csv(paste0(here(), "/data/ipsc_splicing_results.csv"))
ipsc_de = read_csv(paste0(here(), "/data/ipsc_differential_expression.csv"))

col_data <- data.frame(sample = colnames(counts)) %>%
  mutate(condition = ifelse(str_detect(sample, "tdp"), "tdp_ko", "control"))

dds <- DESeqDataSetFromMatrix(countData = counts,
                              colData = col_data,
                              design= ~condition)
dds <- DESeq(dds)
results_name <- resultsNames(dds)[2]
res <- results(dds, name=results_name)

res_df <- data.frame(res) %>%
  rownames_to_column("gene_id") %>%
  left_join(gencode_v29_info, by = "gene_id")

cryptic_df <- ipsc_splicing %>%
  dplyr::select(gene_name, cryptic_junction) %>%
  unique() %>%
  filter(cryptic_junction)

res_df2 <- res_df %>%
  mutate(cryptic_junction = gene_name %in% cryptic_df$gene_name) %>%
  mutate(label_junction = case_when(gene_name %in% c("UNC13A","AGRN",
                                                     "UNC13B","PFKP","SETD5",
                                                     "ATG4B","STMN2","TARDBP") ~ gene_name)) %>%
  mutate(colour = ifelse(cryptic_junction, "#fe6101",  "#648FFF")) %>%
  arrange(colour)
```
   
```{r, warning=FALSE} 
p1 <- ggplot(res_df2, aes(x = log2FoldChange, y = -log10(pvalue), label = label_junction)) +
  geom_point(data = res_df2 %>% filter(!cryptic_junction),
             aes(x = log2FoldChange, y= -log10(pvalue)), color = "#648FFF") +
  geom_point(data = res_df2 %>% filter(cryptic_junction),
             aes(x = log2FoldChange, y= -log10(pvalue)), color = "#fe6101") +
  ggpubr::theme_pubr() +
  ylab("-Log10(p-value)") +
  xlab("Log2 fold change") +
  geom_text_repel(box.padding = 1.2, max.overlaps = Inf)

p2 <- p1 + ylim(0,10)
p1
p2
```

## Targeted RNA-seq

Read in data from processed bam files

TODO: add scripts which deduplicate UMIs for each.

```{r message=FALSE, warning=FALSE}
specific_rt <- read_csv(paste0(here(), "/data/targeted_RNA_seq/specific_RT_primer/for_plot.csv")) %>%
    select(risk, sample_name, n)

random_hexamer <- read_csv(paste0(here(), "/data/targeted_RNA_seq/random_hexamer/values_for_plot.csv")) %>%
    select(-sample_name) %>%
    select(sample_name = actual_sample_name, risk, n)

tg_rnaseq_df <- bind_rows(specific_rt, random_hexamer) %>%
  group_by(sample_name) %>%
  mutate(n_healthy = ifelse(risk == "Non-Risk", n, 0)) %>%
  mutate(combined_healthy = sum(n_healthy)) %>%
  select(-n_healthy) %>%
  mutate(combined = sum(n)) %>%
  group_by(sample_name, risk) %>%
  mutate(combined_n = sum(n)) %>%
  ungroup() %>%
  select(-n) %>%
  unique() %>%
  group_by(sample_name) %>%
  mutate(p_value = pbinom(combined_healthy, sum(combined_n), 0.5)) %>%  # single-tailed bionomial test
  ungroup() %>%
  mutate(sample_name_ordered = fct_reorder(sample_name, dplyr::desc(combined_n)))

ggplot(tg_rnaseq_df %>%
         filter(combined_n > 0), aes(x = sample_name_ordered, y = combined_n, fill = risk)) +
  geom_bar(stat="identity", position="dodge") +
  geom_text(aes(x=sample_name, y=-2.5, label=signif(p_value,2)), size = 3.5) +
  xlab("") +
  ylab("Unique cDNAs") +
  ggeasy::easy_add_legend_title("Allele") +
  theme_minimal() +
  ggpubr::theme_pubr() +
  ggeasy::easy_rotate_x_labels()
```

## iCLIP of minigenes

Read in the processed data (following alignment with Bowtie2, and filtering for high-confidence alignments), and generate
a plot of the overall distribution of crosslinks, and the rolling average difference between the 2x Risk and 2x Healthy.

Next, filter for peaks in the iCLIP signal, and see how they change in 2x Risk versus 2x Healthy. Highlight those which are close to the SNPs.

TODO: add script which does this filtering
TODO: add fasta files for the minigenes

```{r message=FALSE, warning=FALSE}
library(patchwork)

exon_snp <- 556 
intron_snp <- 1106
intron_start <- 141 
intron_end <- 1429
acceptor1 <- 394
acceptor2 <- 444
donor <- 572
mg_l <- 1624 
cpoor_start <- 490
cpoor_end <- 1325
risk_colour <- "#00BFC4"
healthy_colour <- "#F8766D"
confidence_interval <- 0.75  # fracion, i.e. 0.75 = 75%.
peak_threshold <- 5 # how many times above the mean to be a "peak"
region_length <- 50

filtered_df <- read_csv(paste0(here(), "/data/iCLIP/bowtie2_aligned_2_filtered_df.csv"))

rolling_window <- 20
peak_t <- peak_threshold*1000/mg_l  # by definition...
  
df2 <- filtered_df %>%
  ungroup() %>%
  group_by(condition, pos) %>%
  mutate(mean_counts = sum(normalised_counts)/2) %>%
  select(pos, condition, mean_counts) %>%
  unique() %>%
  pivot_wider(names_from = "condition", values_from ="mean_counts") 

df2[is.na(df2)] <- 0
  
df2 <- df2 %>% 
  mutate(diff = R-H) %>%
  mutate(mean_4 = (H+R)/2) %>%
  arrange(pos) 
  
top <- ggplot(df2, aes(x=pos, y=diff)) +
  geom_area(aes(x=pos, y = mean_4), colour="grey50", fill = "grey50", alpha=0.2) +
  geom_vline(xintercept = exon_snp, linetype="dashed") +
  geom_vline(xintercept = intron_snp, linetype="dashed") +
  xlim(1,1600) +
  theme_minimal() +
  ylab("XLs per 1000") +
  xlab("") +
  geom_vline(xintercept = cpoor_start) +
  geom_vline(xintercept = cpoor_end) 
  
bottom <- ggplot(df2, aes(x=pos, y=zoo::rollmean(diff, k = rolling_window, na.pad=T))) +
  geom_area(colour = "grey50", fill="grey50", alpha = 1) +
  geom_vline(xintercept =  exon_snp, linetype="dashed") +
  geom_vline(xintercept =  intron_snp, linetype="dashed") +
  xlim(1,1600) +
  ylim(-0.5,0.75) +
  theme_minimal() +
  ylab("Change in XL density") +
  xlab("Distance from start of minigene") +
  geom_vline(xintercept =  intron_start) +
  geom_vline(xintercept =  intron_end) +
  geom_vline(xintercept =  acceptor1) +
  geom_vline(xintercept =  acceptor2) +
  geom_vline(xintercept =  donor) 

combined <- top/bottom
combined

find_ratio_bound <- function(e_x, sem_x, e_y, sem_y, quantile_value, randoms = 10000){
  # monte carlo confidence interval estimate for a ratio. Assumes the two variables
  # x and y are normally distributed. Finds confidence interval for (x-y)/y
  
  # randomly generate possible global means for x and y
  
  xs = rnorm(randoms, mean = e_x, sd=sem_x)  # risk
  ys = rnorm(randoms, mean = e_y, sd=sem_y)  # healthy
  
  ratios = (xs-ys)/ys
  
  return(quantile(ratios, quantile_value))
}

peak_df <- filtered_df %>%
  ungroup() %>%
  group_by(pos) %>%
  mutate(max_at_pos = max(normalised_counts)) %>%  # at least 1 of the 4 samples above the threshold
  ungroup() %>%
  filter(max_at_pos >= peak_t) %>%  # at least 1 of the 4 samples above the threshold
  group_by(condition, pos) %>%
  mutate(peak_mean = mean(normalised_counts), 
         peak_sd = sd(normalised_counts)) %>%
  ungroup() %>%
  select(condition, pos, peak_mean, peak_sd) %>%
  unique() %>%
  pivot_wider(names_from = "condition", values_from = c("peak_mean", "peak_sd")) %>%
  mutate(frac_increase = (peak_mean_R-peak_mean_H)/peak_mean_H) %>%
  mutate(peak_rank = rank(frac_increase)) %>%
  mutate(colour = ifelse(abs(pos-exon_snp)<region_length, "gold", 
                         ifelse(abs(pos-intron_snp)<region_length, "purple", "grey50")))

peak_df$upper_bound <- mapply(find_ratio_bound, 
                        peak_df$peak_mean_R,
                        peak_df$peak_sd_R/sqrt(2), #convert to SEM
                        peak_df$peak_mean_H,
                        peak_df$peak_sd_H/sqrt(2), #convert to SEM
                        0.5*(1+confidence_interval))

peak_df$lower_bound <- mapply(find_ratio_bound, 
                        peak_df$peak_mean_R,
                        peak_df$peak_sd_R/sqrt(2), #convert to SEM
                        peak_df$peak_mean_H,
                        peak_df$peak_sd_H/sqrt(2), #convert to SEM
                        0.5*(1-confidence_interval))

ggplot(peak_df, aes(x = peak_rank, y = 100*frac_increase, fill=colour)) +
  geom_bar(stat="identity") +
  scale_fill_identity() +
  theme_minimal() +
  ggpubr::theme_pubr()+
  ylab("% change in 2x Risk") +
  xlab("Rank") +
  geom_errorbar(aes(ymin = 100*lower_bound, ymax = 100*upper_bound, x = peak_rank), 
                width = 0.3)

```


